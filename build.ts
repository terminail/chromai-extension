// build.ts - Build script for the Chrome extension

import { exec } from 'child_process';
import { promisify } from 'util';
import { copyFile, mkdir, readdir, stat, readFile, writeFile, unlink } from 'fs/promises';
import { existsSync } from 'fs';
import { join, resolve } from 'path';

const execAsync = promisify(exec);

async function copyFileIfExists(src: string, dest: string): Promise<void> {
  try {
    await copyFile(src, dest);
    console.log(`Copied ${src} to ${dest}`);
  } catch (error) {
    console.warn(`Warning: Could not copy ${src}:`, (error as Error).message);
  }
}

async function copyDirRecursive(src: string, dest: string): Promise<void> {
  try {
    const entries = await readdir(src, { withFileTypes: true });
    
    await mkdir(dest, { recursive: true });
    
    for (const entry of entries) {
      const srcPath = join(src, entry.name);
      const destPath = join(dest, entry.name);
      
      if (entry.isDirectory()) {
        await copyDirRecursive(srcPath, destPath);
      } else {
        await copyFile(srcPath, destPath);
        console.log(`Copied ${srcPath} to ${destPath}`);
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not copy directory ${src}:`, (error as Error).message);
  }
}

// Generate TypeScript interfaces for inject.ts
// This function extracts interfaces from types.ts and generates a version suitable for inject.ts
async function generateInjectInterfaces() {
  console.log('Generating interfaces for inject.ts...');
  
  // Read the types.ts file
  const typesFilePath = join(process.cwd(), 'types.ts');
  const typesContent = await readFile(typesFilePath, 'utf-8');
  
  // Extract the interfaces we need for inject.ts
  let generatedContent = `// inject-interfaces.ts - Generated interfaces for inject.ts
// This file is automatically generated by build.ts
// Do not edit manually - edit types.ts instead

`;

  // Add the StreamingMessageType enum
  generatedContent += `/**
 * Enum for streaming message types shared across components
 */
enum StreamingMessageType {
  STREAMING_STARTED = 'STREAMING_STARTED',
  STREAMING_CHUNK = 'STREAMING_CHUNK',
  STREAMING_COMPLETED = 'STREAMING_COMPLETED'
}

`;

  // Add the base interface
  generatedContent += `interface InjectMessageBase {
  type: StreamingMessageType;
  service: string;
  url: string;
  injectId: string;  // Use injectId for clarity and to avoid ambiguity
  timestamp: number;
  source: 'xhr' | 'fetch';
}
`;

  // Add the StreamingRequestStartedMessage interface
  generatedContent += `interface InjectStreamingRequestStartedMessage extends InjectMessageBase {
  type: StreamingMessageType.STREAMING_STARTED;
  requestBody?: any;
  question: string;  // Renamed from questionContent to question
}
`;

  // Add the StreamingRawDataMessage interface with simplified data object
  generatedContent += `interface InjectStreamingChunkDataMessage extends InjectMessageBase {
    type: StreamingMessageType.STREAMING_CHUNK;
    data: {
      rawChunk: string;
    };
  }
`;

  // Add the StreamingCompletedMessage interface
  generatedContent += `interface InjectStreamingCompletedMessage extends InjectMessageBase {
  type: StreamingMessageType.STREAMING_COMPLETED;
  data: {
    // No additional fields needed as url, injectId, and timestamp are in the base interface
  };
}
`;

  // Write the generated content to the dist folder
  const outputPath = join(process.cwd(), 'dist', 'inject-interfaces.ts');
  await writeFile(outputPath, generatedContent);
  
  console.log('Generated inject-interfaces.ts in dist folder successfully!');
}

// Generate monitored services configuration for inject.ts
// This function extracts the monitoredServices configuration from config.ts
async function generateInjectServices() {
  console.log('Generating monitored services configuration for inject.ts...');
  
  // Read the config.ts file
  const configFilePath = join(process.cwd(), 'config.ts');
  const configContent = await readFile(configFilePath, 'utf-8');
  
  // Extract the monitoredServices array
  let generatedContent = `// monitored-services.ts - Generated monitored services configuration for inject.ts
// This file is automatically generated by build.ts
// Do not edit manually - edit config.ts instead

`;

  // Add the MonitoredServiceConfig interface
  generatedContent += `interface MonitoredServiceConfig {
  name: string;
  baseUrl: string;
  requestPatterns: string[];
  serviceName?: string;
}

`;

  // Extract the monitoredServices array from config.ts
  const monitoredServicesMatch = configContent.match(/export const monitoredServices: MonitoredServiceConfig\[] = \[[\s\S]*?\];/);
  if (monitoredServicesMatch) {
    generatedContent += monitoredServicesMatch[0];
  } else {
    // Fallback if we can't extract the monitoredServices array
    generatedContent += `const monitoredServices: MonitoredServiceConfig[] = [];`;
  }

  // Write the generated content to the dist folder
  const outputPath = join(process.cwd(), 'dist', 'monitored-services.ts');
  await writeFile(outputPath, generatedContent);
  
  console.log('Generated monitored-services.ts in dist folder successfully!');
}

async function buildExtension() {
  console.log('Building Chrome Extension...');
  
  try {
    // Create dist directory if it doesn't exist
    await mkdir(join(process.cwd(), 'dist'), { recursive: true });
    
    // Generate inject interfaces first
    console.log('Generating inject interfaces...');
    await generateInjectInterfaces();
    
    // Generate monitored services configuration
    console.log('Generating monitored services configuration...');
    await generateInjectServices();
    
    // Compile TypeScript files with proper output structure
    console.log('Compiling TypeScript files...');
    
    // Compile all TypeScript files according to tsconfig.json
    await execAsync('npx tsc --project tsconfig.json');
    
    // Copy necessary files to dist directory
    console.log('Copying assets to dist directory...');
    
    // Copy manifest.json
    await copyFileIfExists('manifest.json', 'dist/manifest.json');
    
    // Copy popup.html
    await copyFileIfExists('popup.html', 'dist/popup.html');
    
    // Copy icons directory
    await copyDirRecursive('icons', 'dist/icons');
    
    console.log('Build completed successfully!');
  } catch (error) {
    console.error('Build failed:', error);
    process.exit(1);
  }
}

// Always run the build function
buildExtension();